/*
Author: Connor Pursell cep0172
Date: 11/15/22
Description: Program to decrypt at least 90% of the possible characters that can be decrypted in a set of 
60-character long ciphertexts that have been created using by reusing a one-time pad on multiple 60-character 
plaintexts. Program prompts user to enter the name of the file containing the ciphertexts and then prints the 
decrypted message with '_' representing still encrypted characters.
*/
#include <stdio.h>
#include <stdlib.h>
#include <bits/stdc++.h>
#include <ctype.h>
#include <iostream>
#include <cstring>
#include <vector>
#include <fstream>
#include <sstream>

using namespace std;

int main()
{
    FILE *fp;                     // file pointer
    int lineCount = 1;            // variable to hold # of lines in input file
    int MAX_FILE_NAME = 100;      // max possible length of file name
    int LINE_LENGTH = 120;        // max possible length of each line in input file
    int CHAR_COUNT = 60;          // Max number of characters represented in each line
    char fileName[MAX_FILE_NAME]; // variable to hold user inputted file name
    char c;                       // char user to iterate through file and count lines

    // Get input file name from user
    printf("Enter the name of the ciphertexts file: ");
    scanf("%s", fileName);

    // Open user specified file
    fp = fopen(fileName, "r");

    // If unable to open file, print error message
    if (fp == NULL)
    {
        printf("Could not open file: %s", fileName);
        return 0;
    }

    //////////PROCESS INPUT////////////////
    // If file opened, get number of ciphertexts to process
    for (c = getc(fp); c != EOF; c = getc(fp))
    {
        if (c == '\n')
        {
            lineCount = lineCount + 1;
        }
    }
    rewind(fp);                               // return pointer to beginning of file
    char cipherTexts[lineCount][LINE_LENGTH]; // array to store each line/ciphertext of file as char array

    // store each ciphertext's characters in cipherTexts array
    for (int i = 0; i < lineCount; i++)
    {
        c = getc(fp);
        for (int j = 0; j < LINE_LENGTH; j++)
        {
            if (c != '\n')
            {
                cipherTexts[i][j] = c;
                c = getc(fp);
            }
        }
        c = getc(fp);
    }
    fclose(fp);

    // Convert every pair of characters in each ciphertext to hex values, store in cipherTextsHex.
    int cipherTextsHex[lineCount][CHAR_COUNT];
    for (int j = 0; j < lineCount; j++){
        // There is definitely a better way to do this, and I definitely don't know what it is
        int test = sscanf(cipherTexts[j], "%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x",
                          &cipherTextsHex[j][0], &cipherTextsHex[j][1], &cipherTextsHex[j][2], &cipherTextsHex[j][3], &cipherTextsHex[j][4],
                          &cipherTextsHex[j][5], &cipherTextsHex[j][6], &cipherTextsHex[j][7], &cipherTextsHex[j][8], &cipherTextsHex[j][9],
                          &cipherTextsHex[j][10], &cipherTextsHex[j][11], &cipherTextsHex[j][12], &cipherTextsHex[j][13], &cipherTextsHex[j][14],
                          &cipherTextsHex[j][15], &cipherTextsHex[j][16], &cipherTextsHex[j][17], &cipherTextsHex[j][18], &cipherTextsHex[j][19],
                          &cipherTextsHex[j][20], &cipherTextsHex[j][21], &cipherTextsHex[j][22], &cipherTextsHex[j][23], &cipherTextsHex[j][24],
                          &cipherTextsHex[j][25], &cipherTextsHex[j][26], &cipherTextsHex[j][27], &cipherTextsHex[j][28], &cipherTextsHex[j][29],
                          &cipherTextsHex[j][30], &cipherTextsHex[j][31], &cipherTextsHex[j][32], &cipherTextsHex[j][33], &cipherTextsHex[j][34],
                          &cipherTextsHex[j][35], &cipherTextsHex[j][36], &cipherTextsHex[j][37], &cipherTextsHex[j][38], &cipherTextsHex[j][39],
                          &cipherTextsHex[j][40], &cipherTextsHex[j][41], &cipherTextsHex[j][42], &cipherTextsHex[j][43], &cipherTextsHex[j][44],
                          &cipherTextsHex[j][45], &cipherTextsHex[j][46], &cipherTextsHex[j][47], &cipherTextsHex[j][48], &cipherTextsHex[j][49],
                          &cipherTextsHex[j][50], &cipherTextsHex[j][51], &cipherTextsHex[j][52], &cipherTextsHex[j][53], &cipherTextsHex[j][54],
                          &cipherTextsHex[j][55], &cipherTextsHex[j][56], &cipherTextsHex[j][57], &cipherTextsHex[j][58], &cipherTextsHex[j][59]);
    }


    ////DECRYPTION/////////
    // Array to hold possible space values&positions
    int possibleSpaces[lineCount][lineCount][CHAR_COUNT];
    // Set all values in both 3d arrays to -1
    for (int i = 0; i < lineCount; i++)
    {
        for (int j = 0; j < lineCount; j++)
        {
            for (int k = 0; k < CHAR_COUNT; k++)
            {
                possibleSpaces[i][j][k] = -1;
            }
        }
    }

    // Compare each character of each ciphertext with corresponding character in all other ciphertexts
    // and store values & positions of possible spaces.
    for (int i = 0; i < lineCount; i++)
    {
        for (int j = 0; j < lineCount; j++)
        {
            if (i != j){
                for (int k = 0; k < CHAR_COUNT; k++){
                    int val = cipherTextsHex[i][k] ^ cipherTextsHex[j][k];
                    if (val >= 65){
                        possibleSpaces[i][j][k] = val;
                    }
                }
            }
        }
    }

    vector<int> spacePositions[lineCount];
    int spaceCount;
    // Compare above results to refine and record space positions
    for (int i = 0; i < lineCount; i++)
    {
        for (int k = 0; k < CHAR_COUNT; k++)
        {
            spaceCount = 0;
            for (int j = 0; j < lineCount; j++)
            {
                if (i != j)
                {
                    if (possibleSpaces[i][j][k] >= 65)
                    {
                        spaceCount++;
                    }
                }
            }
            if (spaceCount >= 2)
            {
                spacePositions[i].push_back(k);
            }
        }
    }

    // Interogate each space position in each ciphertext and remove definitely-not-a-space positions
    for (int i = 0; i < lineCount; i++)
    {
        for (int j = 0; j < lineCount; j++)
        {
            for (int k = 0; k < spacePositions[i].size(); k++)
            {
                if (i != j)
                {
                    int pos = spacePositions[i][k];
                    int xorResult = cipherTextsHex[i][pos] ^ cipherTextsHex[j][pos];
                    if (xorResult < 65 && xorResult != 0)
                    {
                        spacePositions[i].erase(spacePositions[i].begin() + k);
                        k--;
                    }
                }
            }
        }
    }

    // Interogate each space position in each ciphertext:
    // if position appears in all cipher texts, remove
    // from ciphertexts' lists due to being unable to determine which ciphertext the space is in
    // making the position as a space in any of the ciphertexts uncertain
    int occurenceCount = 1;
    vector<int> valuesToRemove;
    for (int k = 0; k < spacePositions[0].size(); k++)
    {
        for (int j = 1; j < lineCount; j++)
        {
            for (int l = 0; l < spacePositions[j].size(); l++)
            {
                if (spacePositions[0][k] == spacePositions[j][l])
                {
                    occurenceCount++;
                }
            }
            if (occurenceCount == (lineCount))
            {
                valuesToRemove.push_back(spacePositions[0][k]);
                spacePositions[0].erase(spacePositions[0].begin() + k);
            }
        }
        occurenceCount = 1;
    }

    // remove found repeating values from remaining spacePositions[1...lineCount]
    for (int i = 0; i < valuesToRemove.size(); i++)
    {
        for (int j = 1; j < lineCount; j++)
        {
            for (int k = 0; k < spacePositions[j].size(); k++)
            {
                if (valuesToRemove[i] == spacePositions[j][k])
                {
                    spacePositions[j].erase(spacePositions[j].begin() + k);
                    k--;
                }
            }
        }
    }



    // Now that spacePositions only contains confirmed space positions
    // produce keys by XOR-ing the ciphertext values at space positions with ascii value of space
    int spaceVal = 32;                    
    int key = -1;                         //temp var to hold key values as they are produced and then stored
    int keys[CHAR_COUNT];                // array to store key values where array index corresponds to position of key
    for (int i = 0; i < CHAR_COUNT; i++) // with all initial values set to -1
    {
        keys[i] = -1;
    }
    for (int i = 0; i < lineCount; i++)
    {
        for (int j = 0; j < spacePositions[i].size(); j++)
        {
            int pos = spacePositions[i][j];
            key = cipherTextsHex[i][pos] ^ spaceVal;
            keys[pos] = key;
        }
    }


    // Use keys to decrypt ciphertexts back to plaintexts
    char plaintexts[lineCount][CHAR_COUNT];     //array to hold decrypted plaintexts
    for (int i = 0; i < lineCount; i++)
    {
        for (int j = 0; j < CHAR_COUNT; j++)
        {
            if (keys[j] == -1)                  //if key for position not found and thus decryption not possible
            {                                   //store '_' to represent still encrypted character.
                plaintexts[i][j] = '_';
            }
            else
            {
                int charVal = cipherTextsHex[i][j] ^ keys[j];
                plaintexts[i][j] = static_cast<char>(charVal);
            }
        }
    }
    
    /////RESULTS///////////////
    //Finally, print final results of decryption
    cout<<"Plaintext Messages:"<<endl;
    for (int i = 0; i < lineCount; i++)
    {
        for (int j = 0; j < CHAR_COUNT; j++)
        {
            cout<<plaintexts[i][j];
        }
        cout << endl;
    }
    
    return 0;
}